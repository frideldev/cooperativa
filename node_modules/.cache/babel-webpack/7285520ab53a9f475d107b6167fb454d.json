{"ast":null,"code":"import _classCallCheck from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license ngx-smart-modal\n * MIT license\n */\nimport { ChangeDetectorRef, Component, EventEmitter, HostListener, Injectable, Input, NgModule, Output, Renderer2, ViewChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"nsmContent\"];\nvar _c1 = [\"nsmDialog\"];\nvar _c2 = [\"nsmOverlay\"];\n\nfunction NgxSmartModalComponent_div_0_button_8_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 9);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxSmartModalComponent_div_0_button_8_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      var ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r5.close();\n    });\n    ɵngcc0.ɵɵelement(1, \"img\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar _c3 = function _c3(a0, a2) {\n  return {\n    \"transparent\": a0,\n    \"overlay\": true,\n    \"nsm-overlay-open\": a2\n  };\n};\n\nvar _c4 = function _c4(a1, a2) {\n  return [\"nsm-dialog\", a1, a2];\n};\n\nfunction NgxSmartModalComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r8 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 1, 2);\n    ɵngcc0.ɵɵlistener(\"click\", function NgxSmartModalComponent_div_0_Template_div_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r8);\n      var ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.dismiss($event);\n    });\n    ɵngcc0.ɵɵelementStart(2, \"div\", 3, 4);\n    ɵngcc0.ɵɵelementStart(4, \"div\", 5, 6);\n    ɵngcc0.ɵɵelementStart(6, \"div\", 7);\n    ɵngcc0.ɵɵprojection(7);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(8, NgxSmartModalComponent_div_0_button_8_Template, 2, 0, \"button\", 8);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"z-index\", ctx_r0.visible ? ctx_r0.layerPosition - 1 : 0 - 1);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(7, _c3, !ctx_r0.backdrop, ctx_r0.openedClass));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵstyleProp(\"z-index\", ctx_r0.visible ? ctx_r0.layerPosition : 0 - 1);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(10, _c4, ctx_r0.customClass, ctx_r0.openedClass ? \"nsm-dialog-open\" : \"nsm-dialog-close\"));\n    ɵngcc0.ɵɵadvance(6);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.closable);\n  }\n}\n\nvar _c5 = [\"*\"];\n\nvar NgxSmartModalService = /*@__PURE__*/function () {\n  var NgxSmartModalService = /*#__PURE__*/function () {\n    function NgxSmartModalService() {\n      _classCallCheck(this, NgxSmartModalService);\n\n      this.modalStack = [];\n    }\n    /**\n     * Add a new modal instance. This step is essential and allows to retrieve any modal at any time.\n     * It stores an object that contains the given modal identifier and the modal itself directly in the `modalStack`.\n     *\n     * @param {?} modalInstance The object that contains the given modal identifier and the modal itself.\n     * @param {?=} force Optional parameter that forces the overriding of modal instance if it already exists.\n     * @return {?} nothing special.\n     */\n\n\n    _createClass(NgxSmartModalService, [{\n      key: \"addModal\",\n      value: function addModal(modalInstance, force) {\n        if (force) {\n          var\n          /** @type {?} */\n          i = this.modalStack.findIndex(function (o) {\n            return o.id === modalInstance.id;\n          });\n\n          if (i > -1) {\n            this.modalStack[i].modal = modalInstance.modal;\n          } else {\n            this.modalStack.push(modalInstance);\n          }\n\n          return;\n        }\n\n        this.modalStack.push(modalInstance);\n      }\n      /**\n       * Retrieve a modal instance by its identifier.\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @return {?}\n       */\n\n    }, {\n      key: \"getModal\",\n      value: function getModal(id) {\n        return this.modalStack.filter(function (o) {\n          return o.id === id;\n        })[0].modal;\n      }\n      /**\n       * Alias of `getModal` to retrieve a modal instance by its identifier.\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @return {?}\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(id) {\n        return this.getModal(id);\n      }\n      /**\n       * Open a given modal\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @param {?=} force Tell the modal to open top of all other opened modals\n       * @return {?}\n       */\n\n    }, {\n      key: \"open\",\n      value: function open(id) {\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var\n        /** @type {?} */\n        instance = this.modalStack.find(function (o) {\n          return o.id === id;\n        });\n\n        if (!!instance) {\n          instance.modal.open(force);\n        } else {\n          throw new Error('Modal not found');\n        }\n      }\n      /**\n       * Close a given modal\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @return {?}\n       */\n\n    }, {\n      key: \"close\",\n      value: function close(id) {\n        var\n        /** @type {?} */\n        instance = this.modalStack.find(function (o) {\n          return o.id === id;\n        });\n\n        if (!!instance) {\n          instance.modal.close();\n        } else {\n          throw new Error('Modal not found');\n        }\n      }\n      /**\n       * Toggles a given modal\n       * If the retrieved modal is opened it closes it, else it opens it.\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @param {?=} force Tell the modal to open top of all other opened modals\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle(id) {\n        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var\n        /** @type {?} */\n        instance = this.modalStack.find(function (o) {\n          return o.id === id;\n        });\n\n        if (!!instance) {\n          instance.modal.toggle(force);\n        } else {\n          throw new Error('Modal not found');\n        }\n      }\n      /**\n       * Retrieve all the created modals.\n       *\n       * @return {?} an array that contains all modal instances.\n       */\n\n    }, {\n      key: \"getModalStack\",\n      value: function getModalStack() {\n        return this.modalStack;\n      }\n      /**\n       * Retrieve all the opened modals. It looks for all modal instances with their `visible` property set to `true`.\n       *\n       * @return {?} an array that contains all the opened modals.\n       */\n\n    }, {\n      key: \"getOpenedModals\",\n      value: function getOpenedModals() {\n        var\n        /** @type {?} */\n        modals = [];\n        this.modalStack.forEach(function (o) {\n          if (o.modal.visible) {\n            modals.push(o);\n          }\n        });\n        return modals;\n      }\n      /**\n       * Get the higher `z-index` value between all the modal instances. It iterates over the `ModalStack` array and\n       * calculates a higher value (it takes the highest index value between all the modal instances and adds 1).\n       * Use it to make a modal appear foreground.\n       *\n       * @return {?} a higher index from all the existing modal instances.\n       */\n\n    }, {\n      key: \"getHigherIndex\",\n      value: function getHigherIndex() {\n        var\n        /** @type {?} */\n        index = [1041];\n        var\n        /** @type {?} */\n        modals = this.getModalStack();\n        modals.forEach(function (o) {\n          index.push(o.modal.layerPosition);\n        });\n        return Math.max.apply(Math, index) + 1;\n      }\n      /**\n       * It gives the number of modal instances. It's helpful to know if the modal stack is empty or not.\n       *\n       * @return {?} the number of modal instances.\n       */\n\n    }, {\n      key: \"getModalStackCount\",\n      value: function getModalStackCount() {\n        return this.modalStack.length;\n      }\n      /**\n       * Remove a modal instance from the modal stack.\n       *\n       * @param {?} id The modal identifier.\n       * @return {?} the removed modal instance.\n       */\n\n    }, {\n      key: \"removeModal\",\n      value: function removeModal(id) {\n        var\n        /** @type {?} */\n        i = this.modalStack.findIndex(function (o) {\n          return o.id === id;\n        });\n\n        if (i > -1) {\n          this.modalStack.splice(i, 1);\n        }\n      }\n      /**\n       * Associate data to an identified modal. If the modal isn't already associated to some data, it creates a new\n       * entry in the `modalData` array with its `id` and the given `data`. If the modal already has data, it rewrites\n       * them with the new ones. Finally if no modal found it returns an error message in the console and false value\n       * as method output.\n       *\n       * @param {?} data The data you want to associate to the modal.\n       * @param {?} id The modal identifier.\n       * @param {?=} force If true, overrides the previous stored data if there was.\n       * @return {?} true if the given modal exists and the process has been tried, either false.\n       */\n\n    }, {\n      key: \"setModalData\",\n      value: function setModalData(data, id, force) {\n        if (!!this.modalStack.find(function (o) {\n          return o.id === id;\n        })) {\n          this.getModal(id).setData(data, force);\n          return true;\n        } else {\n          return false;\n        }\n      }\n      /**\n       * Retrieve modal data by its identifier.\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @return {?} the associated modal data.\n       */\n\n    }, {\n      key: \"getModalData\",\n      value: function getModalData(id) {\n        return this.getModal(id).getData();\n      }\n      /**\n       * Reset the data attached to a given modal.\n       *\n       * @param {?} id The modal identifier used at creation time.\n       * @return {?} the removed data or false if modal doesn't exist.\n       */\n\n    }, {\n      key: \"resetModalData\",\n      value: function resetModalData(id) {\n        if (!!this.modalStack.find(function (o) {\n          return o.id === id;\n        })) {\n          var\n          /** @type {?} */\n          removed = this.getModal(id).getData();\n          this.getModal(id).removeData();\n          return removed;\n        } else {\n          return false;\n        }\n      }\n      /**\n       * Close the latest opened modal if it has been declared as escapable\n       * Using a debounce system because one or more modals could be listening\n       * escape key press event.\n       * @return {?}\n       */\n\n    }, {\n      key: \"closeLatestModal\",\n      value: function closeLatestModal() {\n        var\n        /** @type {?} */\n        me = this;\n        clearTimeout(this.debouncer);\n        this.debouncer = setTimeout(function () {\n          var\n          /** @type {?} */\n          tmp;\n          me.getOpenedModals().forEach(function (m) {\n            if (m.modal.layerPosition > (!!tmp ? tmp.modal.layerPosition : 0 && m.modal.escapable)) {\n              tmp = m;\n            }\n          });\n          return !!tmp ? tmp.modal.close() : false;\n        }, 100);\n      }\n    }]);\n\n    return NgxSmartModalService;\n  }();\n\n  NgxSmartModalService.ɵfac = function NgxSmartModalService_Factory(t) {\n    return new (t || NgxSmartModalService)();\n  };\n\n  NgxSmartModalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: NgxSmartModalService,\n    factory: NgxSmartModalService.ɵfac\n  });\n  return NgxSmartModalService;\n}();\n\nvar NgxSmartModalComponent = /*@__PURE__*/function () {\n  var NgxSmartModalComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} _renderer\n     * @param {?} _changeDetectorRef\n     * @param {?} _ngxSmartModalService\n     */\n    function NgxSmartModalComponent(_renderer, _changeDetectorRef, _ngxSmartModalService) {\n      var _this = this;\n\n      _classCallCheck(this, NgxSmartModalComponent);\n\n      this._renderer = _renderer;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._ngxSmartModalService = _ngxSmartModalService;\n      this.closable = true;\n      this.escapable = true;\n      this.dismissable = true;\n      this.identifier = '';\n      this.customClass = 'nsm-dialog-animation-fade';\n      this.visible = false;\n      this.backdrop = true;\n      this.force = true;\n      this.hideDelay = 500;\n      this.autostart = false;\n      this.visibleChange = new EventEmitter();\n      this.onClose = new EventEmitter();\n      this.onCloseFinished = new EventEmitter();\n      this.onDismiss = new EventEmitter();\n      this.onDismissFinished = new EventEmitter();\n      this.onAnyCloseEvent = new EventEmitter();\n      this.onAnyCloseEventFinished = new EventEmitter();\n      this.onOpen = new EventEmitter();\n      this.onEscape = new EventEmitter();\n      this.onDataAdded = new EventEmitter();\n      this.onDataRemoved = new EventEmitter();\n      this.layerPosition = 1041;\n      this.overlayVisible = false;\n      this.openedClass = false;\n\n      this.escapeKeyboardEvent = function (event) {\n        if (event.keyCode === 27) {\n          _this.onEscape.emit(_this);\n\n          _this._ngxSmartModalService.closeLatestModal();\n        }\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(NgxSmartModalComponent, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (!!this.identifier && this.identifier.length) {\n          this.layerPosition += this._ngxSmartModalService.getModalStackCount();\n\n          this._ngxSmartModalService.addModal({\n            id: this.identifier,\n            modal: this\n          }, this.force);\n\n          if (this.autostart) {\n            this._ngxSmartModalService.open(this.identifier);\n          }\n        } else {\n          throw new Error('identifier field isn’t set. Please set one before calling <ngx-smart-modal> in a template.');\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._ngxSmartModalService.removeModal(this.identifier);\n\n        window.removeEventListener('keyup', this.escapeKeyboardEvent);\n\n        if (!this._ngxSmartModalService.getModalStack.length) {\n          this._renderer.removeClass(document.body, 'dialog-open');\n        }\n      }\n      /**\n       * @param {?=} top\n       * @return {?}\n       */\n\n    }, {\n      key: \"open\",\n      value: function open(top) {\n        var _this2 = this;\n\n        if (top) {\n          this.layerPosition = this._ngxSmartModalService.getHigherIndex();\n        }\n\n        this._renderer.addClass(document.body, 'dialog-open');\n\n        this.overlayVisible = true;\n        this.visible = true;\n        setTimeout(function () {\n          _this2.openedClass = true;\n\n          if (_this2.target) {\n            _this2.targetPlacement();\n          }\n\n          _this2._changeDetectorRef.markForCheck();\n        });\n        this.onOpen.emit(this);\n\n        if (this.escapable) {\n          window.addEventListener('keyup', this.escapeKeyboardEvent);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        var\n        /** @type {?} */\n        me = this;\n        this.openedClass = false;\n        this.onClose.emit(this);\n        this.onAnyCloseEvent.emit(this);\n\n        if (this._ngxSmartModalService.getOpenedModals().length < 2) {\n          this._renderer.removeClass(document.body, 'dialog-open');\n        }\n\n        setTimeout(function () {\n          me.visibleChange.emit(me.visible);\n          me.visible = false;\n          me.overlayVisible = false;\n\n          me._changeDetectorRef.markForCheck();\n\n          me.onCloseFinished.emit(me);\n          me.onAnyCloseEventFinished.emit(me);\n        }, this.hideDelay);\n        window.removeEventListener('keyup', this.escapeKeyboardEvent);\n      }\n      /**\n       * @param {?} e\n       * @return {?}\n       */\n\n    }, {\n      key: \"dismiss\",\n      value: function dismiss(e) {\n        var\n        /** @type {?} */\n        me = this;\n\n        if (!this.dismissable) {\n          return;\n        }\n\n        if (e.target.classList.contains('overlay')) {\n          this.openedClass = false;\n          this.onDismiss.emit(this);\n          this.onAnyCloseEvent.emit(this);\n\n          if (this._ngxSmartModalService.getOpenedModals().length < 2) {\n            this._renderer.removeClass(document.body, 'dialog-open');\n          }\n\n          setTimeout(function () {\n            me.visible = false;\n            me.visibleChange.emit(me.visible);\n            me.overlayVisible = false;\n\n            me._changeDetectorRef.markForCheck();\n\n            me.onDismissFinished.emit(me);\n            me.onAnyCloseEventFinished.emit(me);\n          }, this.hideDelay);\n          window.removeEventListener('keyup', this.escapeKeyboardEvent);\n        }\n      }\n      /**\n       * @param {?=} top\n       * @return {?}\n       */\n\n    }, {\n      key: \"toggle\",\n      value: function toggle(top) {\n        if (this.visible) {\n          this.close();\n        } else {\n          this.open(top);\n        }\n      }\n      /**\n       * @param {?} className\n       * @return {?}\n       */\n\n    }, {\n      key: \"addCustomClass\",\n      value: function addCustomClass(className) {\n        if (!this.customClass.length) {\n          this.customClass = className;\n        } else {\n          this.customClass += ' ' + className;\n        }\n      }\n      /**\n       * @param {?=} className\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeCustomClass\",\n      value: function removeCustomClass(className) {\n        if (className) {\n          this.customClass = this.customClass.replace(className, '').trim();\n        } else {\n          this.customClass = '';\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isVisible\",\n      value: function isVisible() {\n        return this.visible;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasData\",\n      value: function hasData() {\n        return this._data !== undefined;\n      }\n      /**\n       * @param {?} data\n       * @param {?=} force\n       * @return {?}\n       */\n\n    }, {\n      key: \"setData\",\n      value: function setData(data, force) {\n        if (!this.hasData() || this.hasData() && force) {\n          this._data = data;\n          this.onDataAdded.emit(this._data);\n\n          this._changeDetectorRef.markForCheck();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getData\",\n      value: function getData() {\n        return this._data;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeData\",\n      value: function removeData() {\n        this._data = undefined;\n        this.onDataRemoved.emit(true);\n\n        this._changeDetectorRef.markForCheck();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"targetPlacement\",\n      value: function targetPlacement() {\n        if (!this.nsmDialog || !this.nsmContent || !this.nsmOverlay || !this.target) {\n          return;\n        }\n\n        var\n        /** @type {?} */\n        targetElementRect = document.querySelector(this.target).getBoundingClientRect();\n        var\n        /** @type {?} */\n        bodyRect = this.nsmOverlay.nativeElement.getBoundingClientRect();\n        var\n        /** @type {?} */\n        nsmContentRect = this.nsmContent.nativeElement.getBoundingClientRect();\n        var\n        /** @type {?} */\n        nsmDialogRect = this.nsmDialog.nativeElement.getBoundingClientRect();\n        var\n        /** @type {?} */\n        marginLeft = parseInt(\n        /** @type {?} */\n        getComputedStyle(this.nsmContent.nativeElement).marginLeft, 10);\n        var\n        /** @type {?} */\n        marginTop = parseInt(\n        /** @type {?} */\n        getComputedStyle(this.nsmContent.nativeElement).marginTop, 10);\n        var\n        /** @type {?} */\n        offsetTop = targetElementRect.top - nsmDialogRect.top - (nsmContentRect.height - targetElementRect.height) / 2;\n        var\n        /** @type {?} */\n        offsetLeft = targetElementRect.left - nsmDialogRect.left - (nsmContentRect.width - targetElementRect.width) / 2;\n\n        if (offsetLeft + nsmDialogRect.left + nsmContentRect.width + marginLeft * 2 > bodyRect.width) {\n          offsetLeft = bodyRect.width - (nsmDialogRect.left + nsmContentRect.width) - marginLeft * 2;\n        } else if (offsetLeft + nsmDialogRect.left < 0) {\n          offsetLeft = -nsmDialogRect.left;\n        }\n\n        if (offsetTop + nsmDialogRect.top + nsmContentRect.height + marginTop > bodyRect.height) {\n          offsetTop = bodyRect.height - (nsmDialogRect.top + nsmContentRect.height) - marginTop;\n        }\n\n        if (offsetTop < 0) {\n          offsetTop = 0;\n        }\n\n        this._renderer.setStyle(this.nsmContent.nativeElement, 'top', offsetTop + 'px');\n\n        this._renderer.setStyle(this.nsmContent.nativeElement, 'left', offsetLeft + 'px');\n      }\n    }]);\n\n    return NgxSmartModalComponent;\n  }();\n\n  NgxSmartModalComponent.ɵfac = function NgxSmartModalComponent_Factory(t) {\n    return new (t || NgxSmartModalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NgxSmartModalService));\n  };\n\n  NgxSmartModalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: NgxSmartModalComponent,\n    selectors: [[\"ngx-smart-modal\"]],\n    viewQuery: function NgxSmartModalComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, true);\n        ɵngcc0.ɵɵviewQuery(_c1, true);\n        ɵngcc0.ɵɵviewQuery(_c2, true);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nsmContent = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nsmDialog = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nsmOverlay = _t.first);\n      }\n    },\n    hostBindings: function NgxSmartModalComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"resize\", function NgxSmartModalComponent_resize_HostBindingHandler() {\n          return ctx.targetPlacement();\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      closable: \"closable\",\n      escapable: \"escapable\",\n      dismissable: \"dismissable\",\n      identifier: \"identifier\",\n      customClass: \"customClass\",\n      visible: \"visible\",\n      backdrop: \"backdrop\",\n      force: \"force\",\n      hideDelay: \"hideDelay\",\n      autostart: \"autostart\",\n      target: \"target\"\n    },\n    outputs: {\n      visibleChange: \"visibleChange\",\n      onClose: \"onClose\",\n      onCloseFinished: \"onCloseFinished\",\n      onDismiss: \"onDismiss\",\n      onDismissFinished: \"onDismissFinished\",\n      onAnyCloseEvent: \"onAnyCloseEvent\",\n      onAnyCloseEventFinished: \"onAnyCloseEventFinished\",\n      onOpen: \"onOpen\",\n      onEscape: \"onEscape\",\n      onDataAdded: \"onDataAdded\",\n      onDataRemoved: \"onDataRemoved\"\n    },\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"z-index\", \"ngClass\", \"click\", 4, \"ngIf\"], [3, \"ngClass\", \"click\"], [\"nsmOverlay\", \"\"], [3, \"ngClass\"], [\"nsmDialog\", \"\"], [1, \"nsm-content\"], [\"nsmContent\", \"\"], [1, \"nsm-body\"], [\"type\", \"button\", \"aria-label\", \"Close\", \"class\", \"nsm-dialog-btn-close\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"aria-label\", \"Close\", 1, \"nsm-dialog-btn-close\", 3, \"click\"], [\"src\", \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTUwNS45NDMsNi4wNThjLTguMDc3LTguMDc3LTIxLjE3Mi04LjA3Ny0yOS4yNDksMEw2LjA1OCw0NzYuNjkzYy04LjA3Nyw4LjA3Ny04LjA3NywyMS4xNzIsMCwyOS4yNDkgICAgQzEwLjA5Niw1MDkuOTgyLDE1LjM5LDUxMiwyMC42ODMsNTEyYzUuMjkzLDAsMTAuNTg2LTIuMDE5LDE0LjYyNS02LjA1OUw1MDUuOTQzLDM1LjMwNiAgICBDNTE0LjAxOSwyNy4yMyw1MTQuMDE5LDE0LjEzNSw1MDUuOTQzLDYuMDU4eiIgZmlsbD0iIzAwMDAwMCIvPgoJPC9nPgo8L2c+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTUwNS45NDIsNDc2LjY5NEwzNS4zMDYsNi4wNTljLTguMDc2LTguMDc3LTIxLjE3Mi04LjA3Ny0yOS4yNDgsMGMtOC4wNzcsOC4wNzYtOC4wNzcsMjEuMTcxLDAsMjkuMjQ4bDQ3MC42MzYsNDcwLjYzNiAgICBjNC4wMzgsNC4wMzksOS4zMzIsNi4wNTgsMTQuNjI1LDYuMDU4YzUuMjkzLDAsMTAuNTg3LTIuMDE5LDE0LjYyNC02LjA1N0M1MTQuMDE4LDQ5Ny44NjYsNTE0LjAxOCw0ODQuNzcxLDUwNS45NDIsNDc2LjY5NHoiIGZpbGw9IiMwMDAwMDAiLz4KCTwvZz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K\"]],\n    template: function NgxSmartModalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, NgxSmartModalComponent_div_0_Template, 9, 13, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.overlayVisible);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgClass],\n    encapsulation: 2\n  });\n  return NgxSmartModalComponent;\n}();\n\nvar NgxSmartModalModule = /*@__PURE__*/function () {\n  var NgxSmartModalModule = /*#__PURE__*/function () {\n    function NgxSmartModalModule() {\n      _classCallCheck(this, NgxSmartModalModule);\n    }\n\n    _createClass(NgxSmartModalModule, null, [{\n      key: \"forRoot\",\n\n      /**\n       * Use in AppModule: new instance of NgxSmartModal.\n       * @return {?}\n       */\n      value: function forRoot() {\n        return {\n          ngModule: NgxSmartModalModule,\n          providers: [NgxSmartModalService]\n        };\n      }\n      /**\n       * Use in features modules with lazy loading: new instance of NgxSmartModal.\n       * @return {?}\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild() {\n        return {\n          ngModule: NgxSmartModalModule,\n          providers: [NgxSmartModalService]\n        };\n      }\n    }]);\n\n    return NgxSmartModalModule;\n  }();\n\n  NgxSmartModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: NgxSmartModalModule\n  });\n  NgxSmartModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function NgxSmartModalModule_Factory(t) {\n      return new (t || NgxSmartModalModule)();\n    },\n    imports: [[CommonModule]]\n  });\n  return NgxSmartModalModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxSmartModalModule, {\n    declarations: function declarations() {\n      return [NgxSmartModalComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [NgxSmartModalComponent];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Public classes.\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxSmartModalService, NgxSmartModalComponent, NgxSmartModalModule };","map":null,"metadata":{},"sourceType":"module"}