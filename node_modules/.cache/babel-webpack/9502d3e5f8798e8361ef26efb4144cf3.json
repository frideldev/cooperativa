{"ast":null,"code":"import _get from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createClass from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"D:/Sitemym/frontend04/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { __decorate, __metadata, __param } from 'tslib';\nimport { TemplateRef, Directive, EventEmitter, ContentChild, Input, Output, HostBinding, Component, forwardRef, ContentChildren, QueryList, Host, Optional, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * The `awWizardStepSymbol` directive can be used as an alternative to the `navigationSymbol` input of a [[WizardStep]]\n * to define the step symbol inside the navigation bar.  This way step symbol may contain arbitrary content.\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepSymbol>\n *     ...\n * </ng-template>\n * ```\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nvar _c0 = [\"*\"];\n\nvar _c1 = function _c1(a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    \"vertical\": a0,\n    \"horizontal\": a1,\n    \"small\": a2,\n    \"large-filled\": a3,\n    \"large-filled-symbols\": a4,\n    \"large-empty\": a5,\n    \"large-empty-symbols\": a6\n  };\n};\n\nfunction WizardComponent_aw_wizard_navigation_bar_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"aw-wizard-navigation-bar\", 2);\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"direction\", ctx_r0.navBarDirection)(\"ngClass\", ɵngcc0.ɵɵpureFunction7(2, _c1, ctx_r0.navBarLocation == \"left\", ctx_r0.navBarLocation == \"top\", ctx_r0.navBarLayout == \"small\", ctx_r0.navBarLayout == \"large-filled\", ctx_r0.navBarLayout == \"large-filled-symbols\", ctx_r0.navBarLayout == \"large-empty\", ctx_r0.navBarLayout == \"large-empty-symbols\"));\n  }\n}\n\nfunction WizardComponent_aw_wizard_navigation_bar_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"aw-wizard-navigation-bar\", 2);\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"direction\", ctx_r1.navBarDirection)(\"ngClass\", ɵngcc0.ɵɵpureFunction7(2, _c1, ctx_r1.navBarLocation == \"right\", ctx_r1.navBarLocation == \"bottom\", ctx_r1.navBarLayout == \"small\", ctx_r1.navBarLayout == \"large-filled\", ctx_r1.navBarLayout == \"large-filled-symbols\", ctx_r1.navBarLayout == \"large-empty\", ctx_r1.navBarLayout == \"large-empty-symbols\"));\n  }\n}\n\nvar _c2 = function _c2(a1, a2) {\n  return {\n    \"wizard-steps\": true,\n    \"vertical\": a1,\n    \"horizontal\": a2\n  };\n};\n\nvar _c3 = function _c3(a0) {\n  return {\n    wizardStep: a0\n  };\n};\n\nfunction WizardNavigationBarComponent_li_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 7);\n  }\n\n  if (rf & 2) {\n    var step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", step_r1.stepTitleTemplate.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, step_r1));\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(step_r1.stepTitle);\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 7);\n  }\n\n  if (rf & 2) {\n    var step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", step_r1.stepSymbolTemplate.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, step_r1));\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(step_r1.navigationSymbol.symbol);\n  }\n}\n\nvar _c4 = function _c4(a0, a1, a2, a3, a4, a5) {\n  return {\n    \"current\": a0,\n    \"editing\": a1,\n    \"done\": a2,\n    \"optional\": a3,\n    \"completed\": a4,\n    \"navigable\": a5\n  };\n};\n\nvar _c5 = function _c5(a0) {\n  return {\n    \"font-family\": a0\n  };\n};\n\nfunction WizardNavigationBarComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 1);\n    ɵngcc0.ɵɵelementStart(1, \"a\", 2);\n    ɵngcc0.ɵɵelementStart(2, \"div\", 3);\n    ɵngcc0.ɵɵtemplate(3, WizardNavigationBarComponent_li_1_ng_container_3_Template, 1, 4, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(4, WizardNavigationBarComponent_li_1_ng_container_4_Template, 2, 1, \"ng-container\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"div\", 6);\n    ɵngcc0.ɵɵtemplate(6, WizardNavigationBarComponent_li_1_ng_container_6_Template, 1, 4, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(7, WizardNavigationBarComponent_li_1_ng_container_7_Template, 2, 1, \"ng-container\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var step_r1 = ctx.$implicit;\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction6(8, _c4, ctx_r0.isCurrent(step_r1), ctx_r0.isEditing(step_r1), ctx_r0.isDone(step_r1), ctx_r0.isOptional(step_r1), ctx_r0.isCompleted(step_r1), ctx_r0.isNavigable(step_r1)));\n    ɵngcc0.ɵɵattribute(\"id\", step_r1.stepId);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"awGoToStep\", step_r1);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", step_r1.stepTitleTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !step_r1.stepTitleTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(15, _c5, step_r1.stepSymbolTemplate ? \"\" : step_r1.navigationSymbol.fontFamily));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", step_r1.stepSymbolTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !step_r1.stepSymbolTemplate);\n  }\n}\n\nvar WizardStepSymbolDirective = /*@__PURE__*/function () {\n  var WizardStepSymbolDirective =\n  /**\n   * Constructor\n   *\n   * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepSymbolDirective]]\n   */\n  function WizardStepSymbolDirective(templateRef) {\n    _classCallCheck(this, WizardStepSymbolDirective);\n\n    this.templateRef = templateRef;\n  };\n\n  WizardStepSymbolDirective.ɵfac = function WizardStepSymbolDirective_Factory(t) {\n    return new (t || WizardStepSymbolDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  WizardStepSymbolDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStepSymbolDirective,\n    selectors: [[\"ng-template\", \"awStepSymbol\", \"\"], [\"ng-template\", \"awWizardStepSymbol\", \"\"]]\n  });\n  return WizardStepSymbolDirective;\n}();\n\nvar WizardStepTitleDirective = /*@__PURE__*/function () {\n  /**\n   * The `awWizardStepTitle` directive can be used as an alternative to the `stepTitle` input of a [[WizardStep]]\n   * to define the content of a step title inside the navigation bar.\n   * This step title can be freely created and can contain more than only plain text\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <ng-template awWizardStepTitle>\n   *     ...\n   * </ng-template>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardStepTitleDirective =\n  /**\n   * Constructor\n   *\n   * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepTitleDirective]]\n   */\n  function WizardStepTitleDirective(templateRef) {\n    _classCallCheck(this, WizardStepTitleDirective);\n\n    this.templateRef = templateRef;\n  };\n\n  WizardStepTitleDirective.ɵfac = function WizardStepTitleDirective_Factory(t) {\n    return new (t || WizardStepTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  WizardStepTitleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStepTitleDirective,\n    selectors: [[\"ng-template\", \"awStepTitle\", \"\"], [\"ng-template\", \"awWizardStepTitle\", \"\"]]\n  });\n  return WizardStepTitleDirective;\n}();\n\nvar WizardStep_1;\n\nvar WizardStep = /*@__PURE__*/function () {\n  /**\n   * Basic functionality every type of wizard step needs to provide\n   *\n   * @author Marc Arndt\n   */\n  var WizardStep = WizardStep_1 = /*#__PURE__*/function () {\n    function WizardStep() {\n      _classCallCheck(this, WizardStep);\n\n      /**\n       * A symbol property, which contains an optional symbol for the step inside the navigation bar.\n       * Takes effect when `stepSymbolTemplate` is not defined or null.\n       */\n      this.navigationSymbol = {\n        symbol: ''\n      };\n      /**\n       * A boolean describing if the wizard step is currently selected\n       */\n\n      this.selected = false;\n      /**\n       * A boolean describing if the wizard step has been completed\n       */\n\n      this.completed = false;\n      /**\n       * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user\n       *\n       * Users will typically use `CompletedStepDirective` to set this flag\n       */\n\n      this.initiallyCompleted = false;\n      /**\n       * A boolean describing if the wizard step is being edited after being competed\n       *\n       * This flag can only be true when `selected` is true.\n       */\n\n      this.editing = false;\n      /**\n       * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step\n       */\n\n      this.defaultSelected = false;\n      /**\n       * A boolean describing if the wizard step is an optional step\n       */\n\n      this.optional = false;\n      /**\n       * A function or boolean deciding, if this step can be entered\n       */\n\n      this.canEnter = true;\n      /**\n       * A function or boolean deciding, if this step can be exited\n       */\n\n      this.canExit = true;\n      /**\n       * This [[EventEmitter]] is called when the step is entered.\n       * The bound method should be used to do initialization work.\n       */\n\n      this.stepEnter = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called when the step is exited.\n       * The bound method can be used to do cleanup work.\n       */\n\n      this.stepExit = new EventEmitter();\n    }\n    /**\n     * Returns true if this wizard step should be visible to the user.\n     * If the step should be visible to the user false is returned, otherwise true\n     */\n\n\n    _createClass(WizardStep, [{\n      key: \"enter\",\n\n      /**\n       * A function called when the step is entered\n       *\n       * @param direction The direction in which the step is entered\n       */\n      value: function enter(direction) {\n        this.stepEnter.emit(direction);\n      }\n      /**\n       * A function called when the step is exited\n       *\n       * @param direction The direction in which the step is exited\n       */\n\n    }, {\n      key: \"exit\",\n      value: function exit(direction) {\n        this.stepExit.emit(direction);\n      }\n      /**\n       * This method returns true, if this wizard step can be entered from the given direction.\n       * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n       * nor a function.\n       *\n       * @param direction The direction in which this step should be entered\n       * @returns A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n       * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n       */\n\n    }, {\n      key: \"canEnterStep\",\n      value: function canEnterStep(direction) {\n        return WizardStep_1.canTransitionStep(this.canEnter, direction);\n      }\n      /**\n       * This method returns true, if this wizard step can be exited into given direction.\n       * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n       * nor a function.\n       *\n       * @param direction The direction in which this step should be left\n       * @returns A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n       * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n       */\n\n    }, {\n      key: \"canExitStep\",\n      value: function canExitStep(direction) {\n        return WizardStep_1.canTransitionStep(this.canExit, direction);\n      }\n    }, {\n      key: \"hidden\",\n      get: function get() {\n        return !this.selected;\n      }\n      /**\n       * This method returns true, if this wizard step can be transitioned with a given direction.\n       * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n       *\n       * @param condition A condition variable, deciding if the step can be transitioned\n       * @param direction The direction in which this step should be transitioned\n       * @returns A [[Promise]] containing `true`, if this step can transitioned in the given direction\n       * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n       */\n\n    }], [{\n      key: \"canTransitionStep\",\n      value: function canTransitionStep(condition, direction) {\n        if (typeof condition === typeof true) {\n          return Promise.resolve(condition);\n        } else if (condition instanceof Function) {\n          return Promise.resolve(condition(direction));\n        } else {\n          return Promise.reject(new Error(\"Input value '\".concat(condition, \"' is neither a boolean nor a function\")));\n        }\n      }\n    }]);\n\n    return WizardStep;\n  }();\n\n  WizardStep.ɵfac = function WizardStep_Factory(t) {\n    return new (t || WizardStep)();\n  };\n\n  WizardStep.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStep,\n    contentQueries: function WizardStep_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStepTitleDirective, true);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStepSymbolDirective, true);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTitleTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepSymbolTemplate = _t.first);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function WizardStep_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"hidden\", ctx.hidden);\n      }\n    },\n    inputs: {\n      navigationSymbol: \"navigationSymbol\",\n      canEnter: \"canEnter\",\n      canExit: \"canExit\",\n      stepId: \"stepId\",\n      stepTitle: \"stepTitle\"\n    },\n    outputs: {\n      stepEnter: \"stepEnter\",\n      stepExit: \"stepExit\"\n    }\n  });\n  return WizardStep;\n}();\n\nvar WizardCompletionStep = /*@__PURE__*/function () {\n  /**\n   * Basic functionality every wizard completion step needs to provide\n   *\n   * @author Marc Arndt\n   */\n  var WizardCompletionStep = /*#__PURE__*/function (_WizardStep) {\n    _inherits(WizardCompletionStep, _WizardStep);\n\n    var _super = _createSuper(WizardCompletionStep);\n\n    function WizardCompletionStep() {\n      var _this;\n\n      _classCallCheck(this, WizardCompletionStep);\n\n      _this = _super.apply(this, arguments);\n      /**\n       * @inheritDoc\n       */\n\n      _this.stepExit = new EventEmitter();\n      /**\n       * @inheritDoc\n       */\n\n      _this.canExit = false;\n      return _this;\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    _createClass(WizardCompletionStep, [{\n      key: \"enter\",\n      value: function enter(direction) {\n        this.completed = true;\n        this.stepEnter.emit(direction);\n      }\n      /**\n       * @inheritDoc\n       */\n\n    }, {\n      key: \"exit\",\n      value: function exit(direction) {\n        // set this completion step as incomplete (unless it happens to be initiallyCompleted)\n        this.completed = this.initiallyCompleted;\n        this.stepExit.emit(direction);\n      }\n    }]);\n\n    return WizardCompletionStep;\n  }(WizardStep);\n\n  WizardCompletionStep.ɵfac = function WizardCompletionStep_Factory(t) {\n    return ɵWizardCompletionStep_BaseFactory(t || WizardCompletionStep);\n  };\n\n  WizardCompletionStep.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardCompletionStep,\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return WizardCompletionStep;\n}();\n\nvar WizardCompletionStepComponent_1;\n\nvar WizardCompletionStepComponent = /*@__PURE__*/function () {\n  /**\n   * The `aw-wizard-completion-step` component can be used to define a completion/success step at the end of your wizard\n   * After a `aw-wizard-completion-step` has been entered, it has the characteristic that the user is blocked from\n   * leaving it again to a previous step.\n   * In addition entering a `aw-wizard-completion-step` automatically sets the `aw-wizard` and all steps inside the `aw-wizard`\n   * as completed.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-completion-step [stepTitle]=\"title of the wizard step\"\n   *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'navigation symbol font family' }\"\n   *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n   *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n   *    ...\n   * </aw-wizard-completion-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n   *    ...\n   * </aw-wizard-completion-step>\n   * ```\n   *\n   * With a navigation symbol from the `font-awesome` font:\n   *\n   * ```html\n   * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n   *    ...\n   * </aw-wizard-completion-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardCompletionStepComponent = WizardCompletionStepComponent_1 = /*#__PURE__*/function (_WizardCompletionStep) {\n    _inherits(WizardCompletionStepComponent, _WizardCompletionStep);\n\n    var _super2 = _createSuper(WizardCompletionStepComponent);\n\n    function WizardCompletionStepComponent() {\n      _classCallCheck(this, WizardCompletionStepComponent);\n\n      return _super2.apply(this, arguments);\n    }\n\n    return WizardCompletionStepComponent;\n  }(WizardCompletionStep);\n\n  WizardCompletionStepComponent.ɵfac = function WizardCompletionStepComponent_Factory(t) {\n    return ɵWizardCompletionStepComponent_BaseFactory(t || WizardCompletionStepComponent);\n  };\n\n  WizardCompletionStepComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardCompletionStepComponent,\n    selectors: [[\"aw-wizard-completion-step\"]],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: WizardStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardCompletionStepComponent_1;\n      })\n    }, {\n      provide: WizardCompletionStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardCompletionStepComponent_1;\n      })\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function WizardCompletionStepComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return WizardCompletionStepComponent;\n}();\n/**\n * The direction in which a step transition was made\n *\n * @author Marc Arndt\n */\n\n/**\n * This enum contains the different possible moving directions in which a wizard can be traversed\n *\n * @author Marc Arndt\n */\n\n\nvar MovingDirection = /*@__PURE__*/function (MovingDirection) {\n  /**\n   * A forward step transition\n   */\n  MovingDirection[MovingDirection[\"Forwards\"] = 0] = \"Forwards\";\n  /**\n   * A backward step transition\n   */\n\n  MovingDirection[MovingDirection[\"Backwards\"] = 1] = \"Backwards\";\n  /**\n   * No step transition was done\n   */\n\n  MovingDirection[MovingDirection[\"Stay\"] = 2] = \"Stay\";\n  return MovingDirection;\n}({});\n/**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n */\n\n\nvar BaseNavigationMode = /*#__PURE__*/function () {\n  function BaseNavigationMode() {\n    _classCallCheck(this, BaseNavigationMode);\n  }\n\n  _createClass(BaseNavigationMode, [{\n    key: \"canGoToStep\",\n\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * In this implementation, a destination wizard step can be entered if:\n     * - it exists\n     * - the current step can be exited in the direction of the destination step\n     * - the destination step can be entered in the direction from the current step\n     *\n     * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination step\n     * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n    value: function canGoToStep(wizard, destinationIndex) {\n      var _this2 = this;\n\n      var hasStep = wizard.hasStep(destinationIndex);\n      var movingDirection = wizard.getMovingDirection(destinationIndex);\n\n      var canExitCurrentStep = function canExitCurrentStep(previous) {\n        return previous && wizard.currentStep.canExitStep(movingDirection);\n      };\n\n      var canEnterDestinationStep = function canEnterDestinationStep(previous) {\n        return previous && wizard.getStepAtIndex(destinationIndex).canEnterStep(movingDirection);\n      };\n\n      var canTransitionToStep = function canTransitionToStep(previous) {\n        return previous && _this2.canTransitionToStep(wizard, destinationIndex);\n      };\n\n      return Promise.resolve(hasStep).then(canTransitionToStep) // Apply user-defined checks at the end.  They can involve user interaction\n      // which is better to be avoided if navigation mode does not actually allow the transition\n      // (`canTransitionToStep` returns `false`).\n      .then(canExitCurrentStep).then(canEnterDestinationStep);\n    }\n    /**\n     * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n     *\n     * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n     * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n     * by previous/next buttons, but not using the navigation bar.\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination step\n     * @returns `true`, if the destination step can be transitioned to and `false` otherwise\n     */\n\n  }, {\n    key: \"canTransitionToStep\",\n    value: function canTransitionToStep(wizard, destinationIndex) {\n      return this.isNavigable(wizard, destinationIndex);\n    }\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * When entering the destination step, the following actions are done:\n     * - the old current step is set as completed\n     * - the old current step is set as unselected\n     * - the old current step is exited\n     * - the destination step is set as selected\n     * - the destination step is entered\n     *\n     * When the destination step couldn't be entered, the following actions are done:\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination wizard step, which should be entered\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n\n  }, {\n    key: \"goToStep\",\n    value: function goToStep(wizard, destinationIndex, preFinalize, postFinalize) {\n      var _this3 = this;\n\n      this.canGoToStep(wizard, destinationIndex).then(function (navigationAllowed) {\n        if (navigationAllowed) {\n          // the current step can be exited in the given direction\n          var movingDirection = wizard.getMovingDirection(destinationIndex);\n          /* istanbul ignore if */\n\n          if (preFinalize) {\n            preFinalize.emit();\n          } // leave current step\n\n\n          wizard.currentStep.completed = true;\n          wizard.currentStep.exit(movingDirection);\n          wizard.currentStep.editing = false;\n          wizard.currentStep.selected = false;\n\n          _this3.transition(wizard, destinationIndex); // remember if the next step is already completed before entering it to properly set `editing` flag\n\n\n          var wasCompleted = wizard.completed || wizard.currentStep.completed; // go to next step\n\n          wizard.currentStep.enter(movingDirection);\n          wizard.currentStep.selected = true;\n\n          if (wasCompleted) {\n            wizard.currentStep.editing = true;\n          }\n          /* istanbul ignore if */\n\n\n          if (postFinalize) {\n            postFinalize.emit();\n          }\n        } else {\n          // if the current step can't be left, reenter the current step\n          wizard.currentStep.exit(MovingDirection.Stay);\n          wizard.currentStep.enter(MovingDirection.Stay);\n        }\n      });\n    }\n    /**\n     * Transitions the wizard to the given step index.\n     *\n     * Can perform additional actions in particular navigation mode implementations.\n     *\n     * @param wizard The wizard component to operate on\n     * @param destinationIndex The index of the destination wizard step\n     */\n\n  }, {\n    key: \"transition\",\n    value: function transition(wizard, destinationIndex) {\n      wizard.currentStepIndex = destinationIndex;\n    }\n    /**\n     * Resets the state of this wizard.\n     *\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n     * In addition the whole wizard is set as incomplete.\n     *\n     * @param wizard The wizard component to operate on\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset(wizard) {\n      this.ensureCanReset(wizard); // reset the step internal state\n\n      wizard.wizardSteps.forEach(function (step) {\n        step.completed = step.initiallyCompleted;\n        step.selected = false;\n        step.editing = false;\n      }); // set the first step as the current step\n\n      wizard.currentStepIndex = wizard.defaultStepIndex;\n      wizard.currentStep.selected = true;\n      wizard.currentStep.enter(MovingDirection.Forwards);\n    }\n    /**\n     * Checks if wizard configuration allows to perform reset.\n     *\n     * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n     *\n     * Can include additional checks in particular navigation mode implementations.\n     *\n     * @param wizard The wizard component to operate on\n     * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n     */\n\n  }, {\n    key: \"ensureCanReset\",\n    value: function ensureCanReset(wizard) {\n      // the wizard doesn't contain a step with the default step index\n      if (!wizard.hasStep(wizard.defaultStepIndex)) {\n        throw new Error(\"The wizard doesn't contain a step with index \".concat(wizard.defaultStepIndex));\n      }\n    }\n  }]);\n\n  return BaseNavigationMode;\n}();\n/**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\n\n\nvar ConfigurableNavigationMode = /*#__PURE__*/function (_BaseNavigationMode) {\n  _inherits(ConfigurableNavigationMode, _BaseNavigationMode);\n\n  var _super3 = _createSuper(ConfigurableNavigationMode);\n\n  /**\n   * Constructor\n   *\n   * @param navigateBackward Controls whether wizard steps before the current step are navigable\n   * @param navigateForward Controls whether wizard steps before the current step are navigable\n   */\n  function ConfigurableNavigationMode() {\n    var _this4;\n\n    var navigateBackward = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var navigateForward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, ConfigurableNavigationMode);\n\n    _this4 = _super3.call(this);\n    _this4.navigateBackward = navigateBackward;\n    _this4.navigateForward = navigateForward;\n    _this4.navigateBackward = _this4.navigateBackward || 'allow';\n    _this4.navigateForward = _this4.navigateForward || 'deny';\n    return _this4;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ConfigurableNavigationMode, [{\n    key: \"canTransitionToStep\",\n    value: function canTransitionToStep(wizard, destinationIndex) {\n      // if the destination step can be navigated to using the navigation bar,\n      // it should be accessible with [goToStep] as well\n      if (this.isNavigable(wizard, destinationIndex)) {\n        return true;\n      } // navigation with [goToStep] is permitted if all previous steps\n      // to the destination step have been completed or are optional\n\n\n      return wizard.wizardSteps.filter(function (step, index) {\n        return index < destinationIndex && index !== wizard.currentStepIndex;\n      }).every(function (step) {\n        return step.completed || step.optional;\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"transition\",\n    value: function transition(wizard, destinationIndex) {\n      if (this.navigateForward === 'deny') {\n        // set all steps after the destination step to incomplete\n        wizard.wizardSteps.filter(function (step, index) {\n          return wizard.currentStepIndex > destinationIndex && index > destinationIndex;\n        }).forEach(function (step) {\n          return step.completed = false;\n        });\n      }\n\n      _get(_getPrototypeOf(ConfigurableNavigationMode.prototype), \"transition\", this).call(this, wizard, destinationIndex);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"isNavigable\",\n    value: function isNavigable(wizard, destinationIndex) {\n      // Check if the destination step can be navigated to\n      var destinationStep = wizard.getStepAtIndex(destinationIndex);\n\n      if (destinationStep instanceof WizardCompletionStep) {\n        // A completion step can only be entered, if all previous steps have been completed, are optional, or selected\n        var previousStepsCompleted = wizard.wizardSteps.filter(function (step, index) {\n          return index < destinationIndex;\n        }).every(function (step) {\n          return step.completed || step.optional || step.selected;\n        });\n\n        if (!previousStepsCompleted) {\n          return false;\n        }\n      } // Apply navigation pocicies\n\n\n      if (destinationIndex < wizard.currentStepIndex) {\n        // If the destination step is before current, apply the `navigateBackward` policy\n        switch (this.navigateBackward) {\n          case 'allow':\n            return true;\n\n          case 'deny':\n            return false;\n\n          default:\n            throw new Error(\"Invalid value for navigateBackward: \".concat(this.navigateBackward));\n        }\n      } else if (destinationIndex > wizard.currentStepIndex) {\n        // If the destination step is after current, apply the `navigateForward` policy\n        switch (this.navigateForward) {\n          case 'allow':\n            return true;\n\n          case 'deny':\n            return false;\n\n          case 'visited':\n            return destinationStep.completed;\n\n          default:\n            throw new Error(\"Invalid value for navigateForward: \".concat(this.navigateForward));\n        }\n      } else {\n        // Re-entering the current step is not allowed\n        return false;\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"ensureCanReset\",\n    value: function ensureCanReset(wizard) {\n      _get(_getPrototypeOf(ConfigurableNavigationMode.prototype), \"ensureCanReset\", this).call(this, wizard); // the default step is a completion step and the wizard contains more than one step\n\n\n      var defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);\n      var defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;\n\n      if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {\n        throw new Error(\"The default step index \".concat(wizard.defaultStepIndex, \" references a completion step\"));\n      }\n    }\n  }]);\n\n  return ConfigurableNavigationMode;\n}(BaseNavigationMode);\n\nvar WizardComponent = /*@__PURE__*/function () {\n  /**\n   * The `aw-wizard` component defines the root component of a wizard.\n   * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size\n   * of its navigation bar.\n   *\n   * ### Syntax\n   * ```html\n   * <aw-wizard [navBarLocation]=\"location of navigation bar\" [navBarLayout]=\"layout of navigation bar\">\n   *     ...\n   * </aw-wizard>\n   * ```\n   *\n   * ### Example\n   *\n   * Without completion step:\n   *\n   * ```html\n   * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n   *     <aw-wizard-step>...</aw-wizard-step>\n   *     <aw-wizard-step>...</aw-wizard-step>\n   * </aw-wizard>\n   * ```\n   *\n   * With completion step:\n   *\n   * ```html\n   * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n   *     <aw-wizard-step>...</aw-wizard-step>\n   *     <aw-wizard-step>...</aw-wizard-step>\n   *     <aw-wizard-completion-step>...</aw-wizard-completion-step>\n   * </aw-wizard>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardComponent = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     */\n    function WizardComponent() {\n      _classCallCheck(this, WizardComponent);\n\n      /**\n       * The location of the navigation bar inside the wizard.\n       * This location can be either top, bottom, left or right\n       */\n      this.navBarLocation = 'top';\n      /**\n       * The layout of the navigation bar inside the wizard.\n       * The layout can be either small, large-filled, large-empty or large-symbols\n       */\n\n      this.navBarLayout = 'small';\n      /**\n       * The direction in which the steps inside the navigation bar should be shown.\n       * The direction can be either `left-to-right` or `right-to-left`\n       */\n\n      this.navBarDirection = 'left-to-right';\n      this._defaultStepIndex = 0;\n      /**\n       * True, if the navigation bar shouldn't be used for navigating\n       */\n\n      this.disableNavigationBar = false;\n      /**\n       * The navigation mode used to navigate inside the wizard\n       *\n       * For outside access, use the [[navigation]] getter.\n       */\n\n      this._navigation = new ConfigurableNavigationMode();\n      /**\n       * An array representation of all wizard steps belonging to this model\n       *\n       * For outside access, use the [[wizardSteps]] getter.\n       */\n\n      this._wizardSteps = [];\n      /**\n       * The index of the currently visible and selected step inside the wizardSteps QueryList.\n       * If this wizard contains no steps, currentStepIndex is -1\n       *\n       * Note: Do not modify this field directly.  Instead, use navigation methods:\n       * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].\n       */\n\n      this.currentStepIndex = -1;\n    }\n    /**\n     * The initially selected step, represented by its index\n     * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n     */\n\n\n    _createClass(WizardComponent, [{\n      key: \"ngAfterContentInit\",\n\n      /**\n       * Initialization work\n       */\n      value: function ngAfterContentInit() {\n        var _this5 = this;\n\n        // add a subscriber to the wizard steps QueryList to listen to changes in the DOM\n        this.wizardStepsQueryList.changes.subscribe(function (changedWizardSteps) {\n          _this5.updateWizardSteps(changedWizardSteps.toArray());\n        }); // initialize the model\n\n        this.updateWizardSteps(this.wizardStepsQueryList.toArray()); // finally reset the whole wizard component\n\n        setTimeout(function () {\n          return _this5.reset();\n        });\n      }\n      /**\n       * The WizardStep object belonging to the currently visible and selected step.\n       * The currentStep is always the currently selected wizard step.\n       * The currentStep can be either completed, if it was visited earlier,\n       * or not completed, if it is visited for the first time or its state is currently out of date.\n       *\n       * If this wizard contains no steps, currentStep is null\n       */\n\n    }, {\n      key: \"updateWizardSteps\",\n\n      /**\n       * Updates the wizard steps to the new array\n       *\n       * @param wizardSteps The updated wizard steps\n       */\n      value: function updateWizardSteps(wizardSteps) {\n        // the wizard is currently not in the initialization phase\n        if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {\n          this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);\n        }\n\n        this._wizardSteps = wizardSteps;\n      }\n      /**\n       * The navigation mode used to navigate inside the wizard\n       */\n\n    }, {\n      key: \"hasStep\",\n\n      /**\n       * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n       *\n       * @param stepIndex The to be checked index of a step inside this wizard\n       * @returns True if the given `stepIndex` is contained inside this wizard, false otherwise\n       */\n      value: function hasStep(stepIndex) {\n        return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;\n      }\n      /**\n       * Checks if this wizard has a previous step, compared to the current step\n       *\n       * @returns True if this wizard has a previous step before the current step\n       */\n\n    }, {\n      key: \"hasPreviousStep\",\n      value: function hasPreviousStep() {\n        return this.hasStep(this.currentStepIndex - 1);\n      }\n      /**\n       * Checks if this wizard has a next step, compared to the current step\n       *\n       * @returns True if this wizard has a next step after the current step\n       */\n\n    }, {\n      key: \"hasNextStep\",\n      value: function hasNextStep() {\n        return this.hasStep(this.currentStepIndex + 1);\n      }\n      /**\n       * Checks if this wizard is currently inside its last step\n       *\n       * @returns True if the wizard is currently inside its last step\n       */\n\n    }, {\n      key: \"isLastStep\",\n      value: function isLastStep() {\n        return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;\n      }\n      /**\n       * Finds the [[WizardStep]] at the given index `stepIndex`.\n       * If no [[WizardStep]] exists at the given index an Error is thrown\n       *\n       * @param stepIndex The given index\n       * @returns The found [[WizardStep]] at the given index `stepIndex`\n       * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n       */\n\n    }, {\n      key: \"getStepAtIndex\",\n      value: function getStepAtIndex(stepIndex) {\n        if (!this.hasStep(stepIndex)) {\n          throw new Error(\"Expected a known step, but got stepIndex: \".concat(stepIndex, \".\"));\n        }\n\n        return this.wizardSteps[stepIndex];\n      }\n      /**\n       * Finds the index of the step with the given `stepId`.\n       * If no step with the given `stepId` exists, `-1` is returned\n       *\n       * @param stepId The given step id\n       * @returns The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n       */\n\n    }, {\n      key: \"getIndexOfStepWithId\",\n      value: function getIndexOfStepWithId(stepId) {\n        return this.wizardSteps.findIndex(function (step) {\n          return step.stepId === stepId;\n        });\n      }\n      /**\n       * Finds the index of the given [[WizardStep]] `step`.\n       * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n       *\n       * @param step The given [[WizardStep]]\n       * @returns The found index of `step` or `-1` if the step is not included in the wizard\n       */\n\n    }, {\n      key: \"getIndexOfStep\",\n      value: function getIndexOfStep(step) {\n        return this.wizardSteps.indexOf(step);\n      }\n      /**\n       * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n       *\n       * @param destinationStep The given destination step\n       * @returns The calculated [[MovingDirection]]\n       */\n\n    }, {\n      key: \"getMovingDirection\",\n      value: function getMovingDirection(destinationStep) {\n        var movingDirection;\n\n        if (destinationStep > this.currentStepIndex) {\n          movingDirection = MovingDirection.Forwards;\n        } else if (destinationStep < this.currentStepIndex) {\n          movingDirection = MovingDirection.Backwards;\n        } else {\n          movingDirection = MovingDirection.Stay;\n        }\n\n        return movingDirection;\n      }\n      /**\n       * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n       *\n       * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n       * Navigation by navigation bar is governed by [[isNavigable]].\n       *\n       * @param destinationIndex The index of the destination step\n       * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n       */\n\n    }, {\n      key: \"canGoToStep\",\n      value: function canGoToStep(destinationIndex) {\n        return this.navigation.canGoToStep(this, destinationIndex);\n      }\n      /**\n       * Tries to transition to the wizard step, as denoted by the given destination index.\n       *\n       * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n       * The [[canGoToStep]] method will be called automatically.\n       *\n       * @param destinationIndex The index of the destination wizard step, which should be entered\n       * @param preFinalize An event emitter, to be called before the step has been transitioned\n       * @param postFinalize An event emitter, to be called after the step has been transitioned\n       */\n\n    }, {\n      key: \"goToStep\",\n      value: function goToStep(destinationIndex, preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);\n      }\n      /**\n       * Tries to transition the wizard to the previous step\n       *\n       * @param preFinalize An event emitter, to be called before the step has been transitioned\n       * @param postFinalize An event emitter, to be called after the step has been transitioned\n       */\n\n    }, {\n      key: \"goToPreviousStep\",\n      value: function goToPreviousStep(preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);\n      }\n      /**\n       * Tries to transition the wizard to the next step\n       *\n       * @param preFinalize An event emitter, to be called before the step has been transitioned\n       * @param postFinalize An event emitter, to be called after the step has been transitioned\n       */\n\n    }, {\n      key: \"goToNextStep\",\n      value: function goToNextStep(preFinalize, postFinalize) {\n        return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);\n      }\n      /**\n       * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n       *\n       * @param destinationIndex The index of the destination step\n       * @returns True if the step can be navigated to, false otherwise\n       */\n\n    }, {\n      key: \"isNavigable\",\n      value: function isNavigable(destinationIndex) {\n        return this.navigation.isNavigable(this, destinationIndex);\n      }\n      /**\n       * Resets the state of this wizard.\n       */\n\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.navigation.reset(this);\n      }\n    }, {\n      key: \"defaultStepIndex\",\n      get: function get() {\n        // This value can be either:\n        // - the index of a wizard step with a `selected` directive, or\n        // - the default step index, set in the [[WizardComponent]]\n        var foundDefaultStep = this.wizardSteps.find(function (step) {\n          return step.defaultSelected;\n        });\n\n        if (foundDefaultStep) {\n          return this.getIndexOfStep(foundDefaultStep);\n        } else {\n          return this._defaultStepIndex;\n        }\n      },\n      set: function set(defaultStepIndex) {\n        this._defaultStepIndex = defaultStepIndex;\n      }\n      /**\n       * Returns true if this wizard uses a horizontal orientation.\n       * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n       *\n       * @returns True if this wizard uses a horizontal orientation\n       */\n\n    }, {\n      key: \"horizontalOrientation\",\n      get: function get() {\n        return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';\n      }\n      /**\n       * Returns true if this wizard uses a vertical orientation.\n       * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n       *\n       * @returns True if this wizard uses a vertical orientation\n       */\n\n    }, {\n      key: \"verticalOrientation\",\n      get: function get() {\n        return this.navBarLocation === 'left' || this.navBarLocation === 'right';\n      }\n    }, {\n      key: \"currentStep\",\n      get: function get() {\n        if (this.hasStep(this.currentStepIndex)) {\n          return this.wizardSteps[this.currentStepIndex];\n        } else {\n          return null;\n        }\n      }\n      /**\n       * The completeness of the wizard.\n       * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n       */\n\n    }, {\n      key: \"completed\",\n      get: function get() {\n        return this.wizardSteps.every(function (step) {\n          return step.completed || step.optional;\n        });\n      }\n      /**\n       * An array representation of all wizard steps belonging to this model\n       */\n\n    }, {\n      key: \"wizardSteps\",\n      get: function get() {\n        return this._wizardSteps;\n      }\n    }, {\n      key: \"navigation\",\n      get: function get() {\n        return this._navigation;\n      }\n      /**\n       * Updates the navigation mode for this wizard component\n       *\n       * @param navigation The updated navigation mode\n       */\n      ,\n      set: function set(navigation) {\n        this._navigation = navigation;\n      }\n    }]);\n\n    return WizardComponent;\n  }();\n\n  WizardComponent.ɵfac = function WizardComponent_Factory(t) {\n    return new (t || WizardComponent)();\n  };\n\n  WizardComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardComponent,\n    selectors: [[\"aw-wizard\"]],\n    contentQueries: function WizardComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStep, true);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wizardStepsQueryList = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function WizardComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"horizontal\", ctx.horizontalOrientation)(\"vertical\", ctx.verticalOrientation);\n      }\n    },\n    inputs: {\n      navBarLocation: \"navBarLocation\",\n      navBarLayout: \"navBarLayout\",\n      navBarDirection: \"navBarDirection\",\n      disableNavigationBar: \"disableNavigationBar\",\n      defaultStepIndex: \"defaultStepIndex\"\n    },\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 6,\n    consts: [[3, \"direction\", \"ngClass\", 4, \"ngIf\"], [3, \"ngClass\"], [3, \"direction\", \"ngClass\"]],\n    template: function WizardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, WizardComponent_aw_wizard_navigation_bar_0_Template, 1, 10, \"aw-wizard-navigation-bar\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(3, WizardComponent_aw_wizard_navigation_bar_3_Template, 1, 10, \"aw-wizard-navigation-bar\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.navBarLocation == \"top\" || ctx.navBarLocation == \"left\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(3, _c2, ctx.navBarLocation == \"left\" || ctx.navBarLocation == \"right\", ctx.navBarLocation == \"top\" || ctx.navBarLocation == \"bottom\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.navBarLocation == \"bottom\" || ctx.navBarLocation == \"right\");\n      }\n    },\n    directives: function directives() {\n      return [ɵngcc1.NgIf, ɵngcc1.NgClass, WizardNavigationBarComponent];\n    },\n    encapsulation: 2\n  });\n  return WizardComponent;\n}();\n\nvar WizardNavigationBarComponent = /*@__PURE__*/function () {\n  /**\n   * The `aw-wizard-navigation-bar` component contains the navigation bar inside a [[WizardComponent]].\n   * To correctly display the navigation bar, it's required to set the right css classes for the navigation bar,\n   * otherwise it will look like a normal `ul` component.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-navigation-bar></aw-wizard-navigation-bar>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardNavigationBarComponent = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state the wizard currently resides in\n     */\n    function WizardNavigationBarComponent(wizard) {\n      _classCallCheck(this, WizardNavigationBarComponent);\n\n      this.wizard = wizard;\n      /**\n       * The direction in which the wizard steps should be shown in the navigation bar.\n       * This value can be either `left-to-right` or `right-to-left`\n       */\n\n      this.direction = 'left-to-right';\n    }\n    /**\n     * Returns all [[WizardStep]]s contained in the wizard\n     *\n     * @returns An array containing all [[WizardStep]]s\n     */\n\n\n    _createClass(WizardNavigationBarComponent, [{\n      key: \"isCurrent\",\n\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as `current`\n       */\n      value: function isCurrent(wizardStep) {\n        return wizardStep.selected;\n      }\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as `editing`\n       */\n\n    }, {\n      key: \"isEditing\",\n      value: function isEditing(wizardStep) {\n        return wizardStep.editing;\n      }\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as `done`\n       */\n\n    }, {\n      key: \"isDone\",\n      value: function isDone(wizardStep) {\n        return wizardStep.completed;\n      }\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as `optional`\n       */\n\n    }, {\n      key: \"isOptional\",\n      value: function isOptional(wizardStep) {\n        return wizardStep.optional;\n      }\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n       *\n       * The `completed` class is only applied to completion steps.\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as `completed`\n       */\n\n    }, {\n      key: \"isCompleted\",\n      value: function isCompleted(wizardStep) {\n        return wizardStep instanceof WizardCompletionStep && this.wizard.completed;\n      }\n      /**\n       * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n       * A wizard step can be navigated to if:\n       * - the step is currently not selected\n       * - the navigation bar isn't disabled\n       * - the navigation mode allows navigation to the step\n       *\n       * @param wizardStep The wizard step to be checked\n       * @returns True if the step can be marked as navigable\n       */\n\n    }, {\n      key: \"isNavigable\",\n      value: function isNavigable(wizardStep) {\n        return !wizardStep.selected && !this.wizard.disableNavigationBar && this.wizard.isNavigable(this.wizard.getIndexOfStep(wizardStep));\n      }\n    }, {\n      key: \"wizardSteps\",\n      get: function get() {\n        switch (this.direction) {\n          case 'right-to-left':\n            return this.wizard.wizardSteps.slice().reverse();\n\n          case 'left-to-right':\n          default:\n            return this.wizard.wizardSteps;\n        }\n      }\n      /**\n       * Returns the number of wizard steps, that need to be displaced in the navigation bar\n       *\n       * @returns The number of wizard steps to be displayed\n       */\n\n    }, {\n      key: \"numberOfWizardSteps\",\n      get: function get() {\n        return this.wizard.wizardSteps.length;\n      }\n    }]);\n\n    return WizardNavigationBarComponent;\n  }();\n\n  WizardNavigationBarComponent.ɵfac = function WizardNavigationBarComponent_Factory(t) {\n    return new (t || WizardNavigationBarComponent)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  WizardNavigationBarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardNavigationBarComponent,\n    selectors: [[\"aw-wizard-navigation-bar\"]],\n    inputs: {\n      direction: \"direction\"\n    },\n    decls: 2,\n    vars: 4,\n    consts: [[3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\"], [3, \"awGoToStep\"], [1, \"label\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"step-indicator\", 3, \"ngStyle\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function WizardNavigationBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\");\n        ɵngcc0.ɵɵtemplate(1, WizardNavigationBarComponent_li_1_Template, 8, 17, \"li\", 0);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate1(\"steps-indicator steps-\", ctx.numberOfWizardSteps, \"\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.wizardSteps);\n      }\n    },\n    directives: function directives() {\n      return [ɵngcc1.NgForOf, ɵngcc1.NgClass, GoToStepDirective, ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgTemplateOutlet];\n    },\n    encapsulation: 2\n  });\n  return WizardNavigationBarComponent;\n}();\n\nvar WizardStepComponent_1;\n\nvar WizardStepComponent = /*@__PURE__*/function () {\n  /**\n   * The `aw-wizard-step` component is used to define a normal step inside a wizard.\n   *\n   * ### Syntax\n   *\n   * With `stepTitle` and `navigationSymbol` inputs:\n   *\n   * ```html\n   * <aw-wizard-step [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n   *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n   *    ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n   *\n   * ```html\n   * <aw-wizard-step\"\n   *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n   *    <ng-template awWizardStepTitle>\n   *        step title\n   *    </ng-template>\n   *    <ng-template awWizardStepSymbol>\n   *        symbol\n   *    </ng-template>\n   *    ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * ### Example\n   *\n   * With `stepTitle` and `navigationSymbol` inputs:\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n   *    ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n   *\n   * ```html\n   * <aw-wizard-step>\n   *    <ng-template awWizardStepTitle>\n   *        Address information\n   *    </ng-template>\n   *    <ng-template awWizardStepSymbol>\n   *        <i class=\"fa fa-taxi\"></i>\n   *    </ng-template>\n   * </aw-wizard-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardStepComponent = WizardStepComponent_1 = /*#__PURE__*/function (_WizardStep2) {\n    _inherits(WizardStepComponent, _WizardStep2);\n\n    var _super4 = _createSuper(WizardStepComponent);\n\n    function WizardStepComponent() {\n      _classCallCheck(this, WizardStepComponent);\n\n      return _super4.apply(this, arguments);\n    }\n\n    return WizardStepComponent;\n  }(WizardStep);\n\n  WizardStepComponent.ɵfac = function WizardStepComponent_Factory(t) {\n    return ɵWizardStepComponent_BaseFactory(t || WizardStepComponent);\n  };\n\n  WizardStepComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardStepComponent,\n    selectors: [[\"aw-wizard-step\"]],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: WizardStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardStepComponent_1;\n      })\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function WizardStepComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return WizardStepComponent;\n}();\n\nvar EnableBackLinksDirective = /*@__PURE__*/function () {\n  /**\n   * The `awEnableBackLinks` directive can be used to allow the user to leave a [[WizardCompletionStep]] after is has been entered.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-completion-step awEnableBackLinks (stepExit)=\"exit function\">\n   *     ...\n   * </aw-wizard-completion-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-completion-step stepTitle=\"Final step\" awEnableBackLinks>\n   *     ...\n   * </aw-wizard-completion-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var EnableBackLinksDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param completionStep The wizard completion step, which should be exitable\n     */\n    function EnableBackLinksDirective(completionStep) {\n      _classCallCheck(this, EnableBackLinksDirective);\n\n      this.completionStep = completionStep;\n      /**\n       * This EventEmitter is called when the step is exited.\n       * The bound method can be used to do cleanup work.\n       */\n\n      this.stepExit = new EventEmitter();\n    }\n    /**\n     * Initialization work\n     */\n\n\n    _createClass(EnableBackLinksDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.completionStep.canExit = true;\n        this.completionStep.stepExit = this.stepExit;\n      }\n    }]);\n\n    return EnableBackLinksDirective;\n  }();\n\n  EnableBackLinksDirective.ɵfac = function EnableBackLinksDirective_Factory(t) {\n    return new (t || EnableBackLinksDirective)(ɵngcc0.ɵɵdirectiveInject(WizardCompletionStep, 1));\n  };\n\n  EnableBackLinksDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: EnableBackLinksDirective,\n    selectors: [[\"\", \"awEnableBackLinks\", \"\"]],\n    outputs: {\n      stepExit: \"stepExit\"\n    }\n  });\n  return EnableBackLinksDirective;\n}();\n/**\n * Checks whether the given `value` implements the interface [[StepId]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepId]] and false otherwise\n */\n\n\nfunction isStepId(value) {\n  return value.hasOwnProperty('stepId') && !(value instanceof WizardStep);\n}\n/**\n * Checks whether the given `value` implements the interface [[StepIndex]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepIndex]] and false otherwise\n */\n\n\nfunction isStepIndex(value) {\n  return value.hasOwnProperty('stepIndex');\n}\n/**\n * Checks whether the given `value` implements the interface [[StepOffset]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepOffset]] and false otherwise\n */\n\n\nfunction isStepOffset(value) {\n  return value.hasOwnProperty('stepOffset');\n}\n\nvar GoToStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awGoToStep` directive can be used to navigate to a given step.\n   * This step can be defined in one of multiple formats\n   *\n   * ### Syntax\n   *\n   * With absolute step index:\n   *\n   * ```html\n   * <button [awGoToStep]=\"{ stepIndex: absolute step index }\" (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * With unique step id:\n   *\n   * ```html\n   * <button [awGoToStep]=\"{ stepId: 'step id of destination step' }\" (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * With a wizard step object:\n   *\n   * ```html\n   * <button [awGoToStep]=\"wizard step object\" (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * With an offset to the defining step:\n   *\n   * ```html\n   * <button [awGoToStep]=\"{ stepOffset: offset }\" (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var GoToStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     * @param wizardStep The wizard step, which contains this [[GoToStepDirective]]\n     */\n    function GoToStepDirective(wizard, wizardStep) {\n      _classCallCheck(this, GoToStepDirective);\n\n      this.wizard = wizard;\n      this.wizardStep = wizardStep;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    _createClass(GoToStepDirective, [{\n      key: \"onClick\",\n\n      /**\n       * Listener method for `click` events on the component with this directive.\n       * After this method is called the wizard will try to transition to the `destinationStep`\n       */\n      value: function onClick() {\n        this.wizard.goToStep(this.destinationStep, this.preFinalize, this.postFinalize);\n      }\n    }, {\n      key: \"finalize\",\n      get: function get() {\n        return this.preFinalize;\n      }\n      /**\n       * A convenience name for `preFinalize`\n       *\n       * @param emitter The [[EventEmitter]] to be set\n       */\n      ,\n      set: function set(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n      }\n      /**\n       * Returns the destination step of this directive as an absolute step index inside the wizard\n       *\n       * @returns The index of the destination step\n       * @throws If `targetStep` is of an unknown type an `Error` is thrown\n       */\n\n    }, {\n      key: \"destinationStep\",\n      get: function get() {\n        var destinationStep;\n\n        if (isStepIndex(this.targetStep)) {\n          destinationStep = this.targetStep.stepIndex;\n        } else if (isStepId(this.targetStep)) {\n          destinationStep = this.wizard.getIndexOfStepWithId(this.targetStep.stepId);\n        } else if (isStepOffset(this.targetStep) && this.wizardStep !== null) {\n          destinationStep = this.wizard.getIndexOfStep(this.wizardStep) + this.targetStep.stepOffset;\n        } else if (this.targetStep instanceof WizardStep) {\n          destinationStep = this.wizard.getIndexOfStep(this.targetStep);\n        } else {\n          throw new Error(\"Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId\");\n        }\n\n        return destinationStep;\n      }\n    }]);\n\n    return GoToStepDirective;\n  }();\n\n  GoToStepDirective.ɵfac = function GoToStepDirective_Factory(t) {\n    return new (t || GoToStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent), ɵngcc0.ɵɵdirectiveInject(WizardStep, 8));\n  };\n\n  GoToStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: GoToStepDirective,\n    selectors: [[\"\", \"awGoToStep\", \"\"]],\n    hostBindings: function GoToStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function GoToStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      targetStep: [\"awGoToStep\", \"targetStep\"]\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n  return GoToStepDirective;\n}();\n\nvar NextStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awNextStep` directive can be used to navigate to the next step.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awNextStep (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var NextStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    function NextStepDirective(wizard) {\n      _classCallCheck(this, NextStepDirective);\n\n      this.wizard = wizard;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    _createClass(NextStepDirective, [{\n      key: \"onClick\",\n\n      /**\n       * Listener method for `click` events on the component with this directive.\n       * After this method is called the wizard will try to transition to the next step\n       */\n      value: function onClick() {\n        this.wizard.goToNextStep(this.preFinalize, this.postFinalize);\n      }\n    }, {\n      key: \"finalize\",\n      get: function get() {\n        return this.preFinalize;\n      }\n      /**\n       * A convenience name for `preFinalize`\n       *\n       * @param emitter The [[EventEmitter]] to be set\n       */\n      ,\n      set: function set(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n      }\n    }]);\n\n    return NextStepDirective;\n  }();\n\n  NextStepDirective.ɵfac = function NextStepDirective_Factory(t) {\n    return new (t || NextStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  NextStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NextStepDirective,\n    selectors: [[\"\", \"awNextStep\", \"\"]],\n    hostBindings: function NextStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NextStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n  return NextStepDirective;\n}();\n\nvar OptionalStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awOptionalStep` directive can be used to define an optional `wizard-step`.\n   * An optional wizard step is a [[WizardStep]] that doesn't need to be completed to transition to later wizard steps.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step awOptionalStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"Second step\" awOptionalStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var OptionalStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[OptionalStepDirective]]\n     */\n    function OptionalStepDirective(wizardStep) {\n      _classCallCheck(this, OptionalStepDirective);\n\n      this.wizardStep = wizardStep; // tslint:disable-next-line:no-input-rename\n\n      this.optional = true;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    _createClass(OptionalStepDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n        this.wizardStep.optional = this.optional || this.optional === '';\n      }\n    }]);\n\n    return OptionalStepDirective;\n  }();\n\n  OptionalStepDirective.ɵfac = function OptionalStepDirective_Factory(t) {\n    return new (t || OptionalStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  OptionalStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: OptionalStepDirective,\n    selectors: [[\"\", \"awOptionalStep\", \"\"]],\n    inputs: {\n      optional: [\"awOptionalStep\", \"optional\"]\n    }\n  });\n  return OptionalStepDirective;\n}();\n\nvar PreviousStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awPreviousStep` directive can be used to navigate to the previous step.\n   * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awPreviousStep>...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var PreviousStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    function PreviousStepDirective(wizard) {\n      _classCallCheck(this, PreviousStepDirective);\n\n      this.wizard = wizard;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    _createClass(PreviousStepDirective, [{\n      key: \"onClick\",\n\n      /**\n       * Listener method for `click` events on the component with this directive.\n       * After this method is called the wizard will try to transition to the previous step\n       */\n      value: function onClick() {\n        this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);\n      }\n    }, {\n      key: \"finalize\",\n      get: function get() {\n        return this.preFinalize;\n      }\n      /**\n       * A convenience field for `preFinalize`\n       *\n       * @param emitter The [[EventEmitter]] to be set\n       */\n      ,\n      set: function set(emitter) {\n        /* istanbul ignore next */\n        this.preFinalize = emitter;\n      }\n    }]);\n\n    return PreviousStepDirective;\n  }();\n\n  PreviousStepDirective.ɵfac = function PreviousStepDirective_Factory(t) {\n    return new (t || PreviousStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  PreviousStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: PreviousStepDirective,\n    selectors: [[\"\", \"awPreviousStep\", \"\"]],\n    hostBindings: function PreviousStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function PreviousStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n  return PreviousStepDirective;\n}();\n\nvar ResetWizardDirective = /*@__PURE__*/function () {\n  /**\n   * The `awResetWizard` directive can be used to reset the wizard to its initial state.\n   * This directive accepts an output, which can be used to specify some custom cleanup work during the reset process.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awResetWizard (finalize)=\"custom reset task\">...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var ResetWizardDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     */\n    function ResetWizardDirective(wizard) {\n      _classCallCheck(this, ResetWizardDirective);\n\n      this.wizard = wizard;\n      /**\n       * An [[EventEmitter]] containing some tasks to be done, directly before the wizard is being reset\n       */\n\n      this.finalize = new EventEmitter();\n    }\n    /**\n     * Resets the wizard\n     */\n\n\n    _createClass(ResetWizardDirective, [{\n      key: \"onClick\",\n      value: function onClick() {\n        // do some optional cleanup work\n        this.finalize.emit(); // reset the wizard to its initial state\n\n        this.wizard.reset();\n      }\n    }]);\n\n    return ResetWizardDirective;\n  }();\n\n  ResetWizardDirective.ɵfac = function ResetWizardDirective_Factory(t) {\n    return new (t || ResetWizardDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  ResetWizardDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ResetWizardDirective,\n    selectors: [[\"\", \"awResetWizard\", \"\"]],\n    hostBindings: function ResetWizardDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ResetWizardDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      finalize: \"finalize\"\n    }\n  });\n  return ResetWizardDirective;\n}();\n\nvar SelectedStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awSelectedStep` directive can be used on a [[WizardStep]] to set it as selected after the wizard initialisation or a reset.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"Step title\" awSelectedStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var SelectedStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which should be selected by default\n     */\n    function SelectedStepDirective(wizardStep) {\n      _classCallCheck(this, SelectedStepDirective);\n\n      this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    _createClass(SelectedStepDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.wizardStep.defaultSelected = true;\n      }\n    }]);\n\n    return SelectedStepDirective;\n  }();\n\n  SelectedStepDirective.ɵfac = function SelectedStepDirective_Factory(t) {\n    return new (t || SelectedStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  SelectedStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SelectedStepDirective,\n    selectors: [[\"\", \"awSelectedStep\", \"\"]]\n  });\n  return SelectedStepDirective;\n}();\n\nvar WizardCompletionStepDirective_1;\n\nvar WizardCompletionStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awWizardCompletionStep` directive can be used to define a completion/success step at the end of your wizard\n   * After a [[WizardCompletionStep]] has been entered, it has the characteristic that the user is blocked from\n   * leaving it again to a previous step.\n   * In addition entering a [[WizardCompletionStep]] automatically sets the `wizard`, and all steps inside the `wizard`,\n   * as completed.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <div awWizardCompletionStep [stepTitle]=\"title of the wizard step\"\n   *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'font-family' }\"\n   *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n   *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n   *    ...\n   * </div>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n   *    ...\n   * </div>\n   * ```\n   *\n   * With a navigation symbol from the `font-awesome` font:\n   *\n   * ```html\n   * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n   *    ...\n   * </div>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardCompletionStepDirective = WizardCompletionStepDirective_1 = /*#__PURE__*/function (_WizardCompletionStep2) {\n    _inherits(WizardCompletionStepDirective, _WizardCompletionStep2);\n\n    var _super5 = _createSuper(WizardCompletionStepDirective);\n\n    function WizardCompletionStepDirective() {\n      _classCallCheck(this, WizardCompletionStepDirective);\n\n      return _super5.apply(this, arguments);\n    }\n\n    return WizardCompletionStepDirective;\n  }(WizardCompletionStep);\n\n  WizardCompletionStepDirective.ɵfac = function WizardCompletionStepDirective_Factory(t) {\n    return ɵWizardCompletionStepDirective_BaseFactory(t || WizardCompletionStepDirective);\n  };\n\n  WizardCompletionStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardCompletionStepDirective,\n    selectors: [[\"\", \"awWizardCompletionStep\", \"\"]],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: WizardStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardCompletionStepDirective_1;\n      })\n    }, {\n      provide: WizardCompletionStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardCompletionStepDirective_1;\n      })\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return WizardCompletionStepDirective;\n}();\n\nvar WizardStepDirective_1;\n\nvar WizardStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awWizardStep` directive can be used to define a normal step inside a wizard.\n   *\n   * ### Syntax\n   *\n   * With `stepTitle` and `navigationSymbol` inputs:\n   *\n   * ```html\n   * <div awWizardStep [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n   *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n   *    ...\n   * </div>\n   * ```\n   *\n   * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n   *\n   * ```html\n   * <div awWizardStep [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n   *    <ng-template awWizardStepTitle>\n   *        step title\n   *    </ng-template>\n   *    <ng-template awWizardStepSymbol>\n   *        symbol\n   *    </ng-template>\n   *    ...\n   * </div>\n   * ```\n   *\n   * ### Example\n   *\n   * With `stepTitle` and `navigationSymbol` inputs:\n   *\n   * ```html\n   * <div awWizardStep stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n   *    ...\n   * </div>\n   * ```\n   *\n   * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n   *\n   * ```html\n   * <div awWizardStep>\n   *    <ng-template awWizardStepTitle>\n   *        Address information\n   *    </ng-template>\n   *    <ng-template awWizardStepSymbol>\n   *        <i class=\"fa fa-taxi\"></i>\n   *    </ng-template>\n   * </div>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n  var WizardStepDirective = WizardStepDirective_1 = /*#__PURE__*/function (_WizardStep3) {\n    _inherits(WizardStepDirective, _WizardStep3);\n\n    var _super6 = _createSuper(WizardStepDirective);\n\n    function WizardStepDirective() {\n      _classCallCheck(this, WizardStepDirective);\n\n      return _super6.apply(this, arguments);\n    }\n\n    return WizardStepDirective;\n  }(WizardStep);\n\n  WizardStepDirective.ɵfac = function WizardStepDirective_Factory(t) {\n    return ɵWizardStepDirective_BaseFactory(t || WizardStepDirective);\n  };\n\n  WizardStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStepDirective,\n    selectors: [[\"\", \"awWizardStep\", \"\"]],\n    features: [/*@__PURE__*/ɵngcc0.ɵɵProvidersFeature([{\n      provide: WizardStep,\n      useExisting: /*@__PURE__*/forwardRef(function () {\n        return WizardStepDirective_1;\n      })\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return WizardStepDirective;\n}();\n\nvar NavigationModeDirective = /*@__PURE__*/function () {\n  /**\n   * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.\n   *\n   * There are several usage options:\n   *\n   * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.\n   *\n   * ```html\n   * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n   * ```\n   *\n   * ### Option 2. Pass in a custom navigation mode\n   *\n   * ```typescript\n   * import { BaseNavigationMode } from 'angular-archwizard'\n   *\n   * class CustomNavigationMode extends BaseNavigationMode {\n   *\n   *   // ...\n   * }\n   * ```\n   *\n   * ```typescript\n   * @Component({\n   *   // ...\n   * })\n   * class MyComponent {\n   *\n   *   navigationMode = new CustomNavigationMode();\n   * }\n   * ```\n   *\n   * ```html\n   * <aw-wizard [awNavigationMode]=\"navigationMode\">...</aw-wizard>\n   * ```\n   *\n   * ### Additional Notes\n   *\n   * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs\n   *\n   * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without\n   *   any inputs or parameters causes the wizard to use the default \"strict\" navigation mode equivalent to\n   *\n   * ```html\n   * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n   * ````\n   */\n  var NavigationModeDirective = /*#__PURE__*/function () {\n    function NavigationModeDirective(wizard) {\n      _classCallCheck(this, NavigationModeDirective);\n\n      this.wizard = wizard;\n    }\n\n    _createClass(NavigationModeDirective, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.wizard.navigation = this.getNavigationMode();\n      }\n    }, {\n      key: \"getNavigationMode\",\n      value: function getNavigationMode() {\n        if (this.awNavigationMode) {\n          return this.awNavigationMode;\n        }\n\n        return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);\n      }\n    }]);\n\n    return NavigationModeDirective;\n  }();\n\n  NavigationModeDirective.ɵfac = function NavigationModeDirective_Factory(t) {\n    return new (t || NavigationModeDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  NavigationModeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NavigationModeDirective,\n    selectors: [[\"\", \"awNavigationMode\", \"\"]],\n    inputs: {\n      awNavigationMode: \"awNavigationMode\",\n      navigateBackward: \"navigateBackward\",\n      navigateForward: \"navigateForward\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return NavigationModeDirective;\n}();\n\nvar CompletedStepDirective = /*@__PURE__*/function () {\n  /**\n   * The `awCompletedStep` directive can be used to make a wizard step initially completed.\n   *\n   * Initially completed steps are shown as completed when the wizard is presented to the user.\n   *\n   * A typical use case is to make a step initially completed if it is automatically filled with some derived/predefined information.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step awCompletedStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * An optional boolean condition can be specified:\n   *\n   * ```html\n   * <aw-wizard-step [awCompletedStep]=\"shouldBeCompleted\">\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"First step\" [awCompletedStep]=\"firstStepPrefilled\">\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   */\n  var CompletedStepDirective = /*#__PURE__*/function () {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[CompletedStepDirective]]\n     */\n    function CompletedStepDirective(wizardStep) {\n      _classCallCheck(this, CompletedStepDirective);\n\n      this.wizardStep = wizardStep; // tslint:disable-next-line:no-input-rename\n\n      this.initiallyCompleted = true;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    _createClass(CompletedStepDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n        this.wizardStep.initiallyCompleted = this.initiallyCompleted || this.initiallyCompleted === '';\n      }\n    }]);\n\n    return CompletedStepDirective;\n  }();\n\n  CompletedStepDirective.ɵfac = function CompletedStepDirective_Factory(t) {\n    return new (t || CompletedStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  CompletedStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CompletedStepDirective,\n    selectors: [[\"\", \"awCompletedStep\", \"\"]],\n    inputs: {\n      initiallyCompleted: [\"awCompletedStep\", \"initiallyCompleted\"]\n    }\n  });\n  return CompletedStepDirective;\n}();\n\nvar ArchwizardModule_1;\n\nvar ArchwizardModule = /*@__PURE__*/function () {\n  /**\n   * The module defining all the content inside `angular-archwizard`\n   *\n   * @author Marc Arndt\n   */\n  var ArchwizardModule = ArchwizardModule_1 = /*#__PURE__*/function () {\n    function ArchwizardModule() {\n      _classCallCheck(this, ArchwizardModule);\n    }\n\n    _createClass(ArchwizardModule, null, [{\n      key: \"forRoot\",\n\n      /* istanbul ignore next */\n      value: function forRoot() {\n        return {\n          ngModule: ArchwizardModule_1,\n          providers: [// Nothing here yet\n          ]\n        };\n      }\n    }]);\n\n    return ArchwizardModule;\n  }();\n\n  ArchwizardModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ArchwizardModule\n  });\n  ArchwizardModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    factory: function ArchwizardModule_Factory(t) {\n      return new (t || ArchwizardModule)();\n    },\n    imports: [[CommonModule]]\n  });\n  return ArchwizardModule;\n}();\n\nvar ɵWizardCompletionStep_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStep);\nvar ɵWizardCompletionStepComponent_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStepComponent);\nvar ɵWizardStepComponent_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(WizardStepComponent);\nvar ɵWizardCompletionStepDirective_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStepDirective);\nvar ɵWizardStepDirective_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(WizardStepDirective);\n/*@__PURE__*/\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ArchwizardModule, {\n    declarations: function declarations() {\n      return [WizardComponent, WizardStepComponent, WizardNavigationBarComponent, WizardCompletionStepComponent, GoToStepDirective, NextStepDirective, PreviousStepDirective, OptionalStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, EnableBackLinksDirective, WizardStepDirective, WizardCompletionStepDirective, SelectedStepDirective, ResetWizardDirective, NavigationModeDirective, CompletedStepDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [WizardComponent, WizardStepComponent, WizardNavigationBarComponent, WizardCompletionStepComponent, GoToStepDirective, NextStepDirective, PreviousStepDirective, OptionalStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, EnableBackLinksDirective, WizardStepDirective, WizardCompletionStepDirective, SelectedStepDirective, ResetWizardDirective, NavigationModeDirective, CompletedStepDirective];\n    }\n  });\n})(); // export the components\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ArchwizardModule, BaseNavigationMode, CompletedStepDirective, ConfigurableNavigationMode, EnableBackLinksDirective, GoToStepDirective, MovingDirection, NavigationModeDirective, NextStepDirective, OptionalStepDirective, PreviousStepDirective, ResetWizardDirective, SelectedStepDirective, WizardCompletionStep, WizardCompletionStepComponent, WizardCompletionStepDirective, WizardComponent, WizardNavigationBarComponent, WizardStep, WizardStepComponent, WizardStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, isStepId, isStepIndex, isStepOffset };","map":null,"metadata":{},"sourceType":"module"}